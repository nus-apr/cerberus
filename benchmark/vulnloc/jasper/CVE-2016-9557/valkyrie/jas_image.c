/*
 * Copyright (c) 1999-2000 Image Power, Inc. and the University of
 *   British Columbia.
 * Copyright (c) 2001-2003 Michael David Adams.
 * All rights reserved.
 */

/* __START_OF_JASPER_LICENSE__
 *
 * JasPer License Version 2.0
 *
 * Copyright (c) 2001-2006 Michael David Adams
 * Copyright (c) 1999-2000 Image Power, Inc.
 * Copyright (c) 1999-2000 The University of British Columbia
 *
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person (the
 * "User") obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * 1.  The above copyright notices and this permission notice (which
 * includes the disclaimer below) shall be included in all copies or
 * substantial portions of the Software.
 *
 * 2.  The name of a copyright holder shall not be used to endorse or
 * promote products derived from the Software without specific prior
 * written permission.
 *
 * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
 * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
 * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
 * "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE
 * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE
 * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.
 * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS
 * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL
 * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS
 * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE
 * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE
 * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL
 * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,
 * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL
 * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH
 * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,
 * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH
 * RISK ACTIVITIES").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY
 * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.
 *
 * __END_OF_JASPER_LICENSE__
 */

/*
 * Image Library
 *
 * $Id$
 */

/******************************************************************************\
* Includes.
\******************************************************************************/

#include <assert.h>
#include <ctype.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "jasper/jas_debug.h"
#include "jasper/jas_image.h"
#include "jasper/jas_malloc.h"
#include "jasper/jas_math.h"
#include "jasper/jas_string.h"

/******************************************************************************\
* Types.
\******************************************************************************/

#define FLOORDIV(x, y) ((x) / (y))

/******************************************************************************\
* Local prototypes.
\******************************************************************************/

static jas_image_cmpt_t *jas_image_cmpt_create0(void);
static void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt);
static jas_image_cmpt_t *
jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly, uint_fast32_t hstep,
                      uint_fast32_t vstep, uint_fast32_t width,
                      uint_fast32_t height, uint_fast16_t depth, bool sgnd,
                      uint_fast32_t inmem);
static void jas_image_setbbox(jas_image_t *image);
static jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt);
static int jas_image_growcmpts(jas_image_t *image, int maxcmpts);
static uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd);
static jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd);
static int putint(jas_stream_t *out, int sgnd, int prec, long val);
static int getint(jas_stream_t *in, int sgnd, int prec, long *val);
static void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,
                                jas_image_coord_t *tly, jas_image_coord_t *brx,
                                jas_image_coord_t *bry);
static long uptomult(long x, long y);
static long downtomult(long x, long y);
static long convert(long val, int oldsgnd, int oldprec, int newsgnd,
                    int newprec);
static void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,
                                jas_image_coord_t *tly, jas_image_coord_t *brx,
                                jas_image_coord_t *bry);

/******************************************************************************\
* Global data.
\******************************************************************************/

static int jas_image_numfmts = 0;
static jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];

/******************************************************************************\
* Create and destroy operations.
\******************************************************************************/

jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
                              int clrspc) {
  jas_image_t *image;
  uint_fast32_t rawsize;
  uint_fast32_t inmem;
  int cmptno;
  jas_image_cmptparm_t *cmptparm;

  /* jump:144 */ if (!(image = jas_image_create0())) {
    return 0;
  }

  image->clrspc_ = clrspc;
  image->maxcmpts_ = numcmpts;
  image->inmem_ = true;

  /* Allocate memory for the per-component information. */
  /* jump:154 */ if (!(image->cmpts_ =jas_alloc2(image->maxcmpts_, sizeof(jas_image_cmpt_t *)))) {
    jas_image_destroy(image);
    return 0;
  }
  /* Initialize in case of failure. */
  /* jump:159 */ for (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {
    image->cmpts_[cmptno] = 0;
    int valkyrie = 0;
  }

  /* Compute the approximate raw size of the image. */
  rawsize = 0;
  /* jump:166 */ for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts;  ++cmptno, ++cmptparm) {
    rawsize += cmptparm->width * cmptparm->height * (cmptparm->prec + 7) / 8;
    int valkyrie = 0;
  }
  /* Decide whether to buffer the image data in memory, based on the
    raw size of the image. */
  inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);

  /* Create the individual image components. */
  /* jump:179 */ for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts;  ++cmptno, ++cmptparm) {
    /* jump:176 */ if (!(image->cmpts_[cmptno] = jas_image_cmpt_create( cmptparm->tlx, cmptparm->tly, cmptparm->hstep, cmptparm->vstep, cmptparm->width, cmptparm->height, cmptparm->prec, cmptparm->sgnd, inmem))) {
      jas_image_destroy(image);
      return 0;
    }
    ++image->numcmpts_;
    int valkyrie = 0;
  }

  /* Determine the bounding box for all of the components on the
    reference grid (i.e., the image area) */
  jas_image_setbbox(image);

  return image;
}

jas_image_t *jas_image_create0() {
  jas_image_t *image;

  /* jump:193 */ if (!(image = jas_malloc(sizeof(jas_image_t)))) {
    return 0;
  }

  image->tlx_ = 0;
  image->tly_ = 0;
  image->brx_ = 0;
  image->bry_ = 0;
  image->clrspc_ = JAS_CLRSPC_UNKNOWN;
  image->numcmpts_ = 0;
  image->maxcmpts_ = 0;
  image->cmpts_ = 0;
  image->inmem_ = true;
  image->cmprof_ = 0;

  return image;
}

jas_image_t *jas_image_copy(jas_image_t *image) {
  jas_image_t *newimage;
  int cmptno;

  /* jump:215 */ if (!(newimage = jas_image_create0())) {
    goto error;
  }

  /* jump:219 */ if (jas_image_growcmpts(newimage, image->numcmpts_)) {
    goto error;
  }
  /* jump:226 */ for (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {
    /* jump:223 */ if (!(newimage->cmpts_[cmptno] =  jas_image_cmpt_copy(image->cmpts_[cmptno]))) {
      goto error;
    }
    ++newimage->numcmpts_;
    int valkyrie = 0;
  }

  jas_image_setbbox(newimage);

  /* jump:234 */ if (image->cmprof_) {
    /* jump:233 */ if (!(newimage->cmprof_ = jas_cmprof_copy(image->cmprof_))){
        goto error;
      }
  }

  return newimage;
error:
  /* jump:240 */ if (newimage) {
    jas_image_destroy(newimage);
  }
  return 0;
}

static jas_image_cmpt_t *jas_image_cmpt_create0() {
  jas_image_cmpt_t *cmpt;
  /* jump:248 */ if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
    return 0;
  }
  memset(cmpt, 0, sizeof(jas_image_cmpt_t));
  cmpt->type_ = JAS_IMAGE_CT_UNKNOWN;
  return cmpt;
}

static jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt) {
  jas_image_cmpt_t *newcmpt;

  /* jump:259 */ if (!(newcmpt = jas_image_cmpt_create0())) {
    return 0;
  }
  newcmpt->tlx_ = cmpt->tlx_;
  newcmpt->tly_ = cmpt->tly_;
  newcmpt->hstep_ = cmpt->hstep_;
  newcmpt->vstep_ = cmpt->vstep_;
  newcmpt->width_ = cmpt->width_;
  newcmpt->height_ = cmpt->height_;
  newcmpt->prec_ = cmpt->prec_;
  newcmpt->sgnd_ = cmpt->sgnd_;
  newcmpt->cps_ = cmpt->cps_;
  newcmpt->type_ = cmpt->type_;
  /* jump:272 */ if (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {
    goto error;
  }
  /* jump:275 */ if (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {
    goto error;
  }
  /* jump:278 */ if (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {
    goto error;
  }
  /* jump:281 */ if (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {
    goto error;
  }
  return newcmpt;
error:
  /* jump:286 */ if (newcmpt) {
    jas_image_cmpt_destroy(newcmpt);
  }
  return 0;
}

void jas_image_destroy(jas_image_t *image) {
  int i;

  /* jump:300 */ if (image->cmpts_) {
    /* jump:298 */ for (i = 0; i < image->numcmpts_; ++i) {
      jas_image_cmpt_destroy(image->cmpts_[i]);
      image->cmpts_[i] = 0;
      int valkyrie = 0;
    }
    jas_free(image->cmpts_);
  }
  /* jump:303 */ if (image->cmprof_){
    jas_cmprof_destroy(image->cmprof_);
  }
  jas_free(image);
}

static jas_image_cmpt_t *
jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly, uint_fast32_t hstep,
                      uint_fast32_t vstep, uint_fast32_t width,
                      uint_fast32_t height, uint_fast16_t depth, bool sgnd,
                      uint_fast32_t inmem) {
  jas_image_cmpt_t *cmpt;
  size_t size;

  /* jump:317 */ if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
    goto error;
  }

  cmpt->type_ = JAS_IMAGE_CT_UNKNOWN;
  cmpt->tlx_ = tlx;
  cmpt->tly_ = tly;
  cmpt->hstep_ = hstep;
  cmpt->vstep_ = vstep;
  cmpt->width_ = width;
  cmpt->height_ = height;
  cmpt->prec_ = depth;
  cmpt->sgnd_ = sgnd;
  cmpt->stream_ = 0;
  cmpt->cps_ = (depth + 7) / 8;

  // Compute the number of samples in the image component, while protecting
  // against overflow.
  // size = cmpt->width_ * cmpt->height_ * cmpt->cps_;
  /* jump:336 */ if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) || !jas_safe_size_mul(size, cmpt->cps_, &size)) {
    goto error;
  }
  cmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : jas_stream_tmpfile();
  /* jump:340 */ if (!cmpt->stream_) {
    goto error;
  }

  /* Zero the component data.  This isn't necessary, but it is
  convenient for debugging purposes. */
  /* Note: conversion of size - 1 to long can overflow */
  /* jump:347 */ if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||  jas_stream_putc(cmpt->stream_, 0) == EOF || jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {
    goto error;
  }

  return cmpt;

error:
  /* jump:354 */ if (cmpt) {
    jas_image_cmpt_destroy(cmpt);
  }
  return 0;
}

static void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt) {
  /* jump:361 */ if (cmpt->stream_) {
    jas_stream_close(cmpt->stream_);
  }
  jas_free(cmpt);
}

/******************************************************************************\
* Load and save operations.
\******************************************************************************/

jas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr) {
  jas_image_fmtinfo_t *fmtinfo;
  jas_image_t *image;

  image = 0;

  /* If possible, try to determine the format of the input data. */
  /* jump:380 */ if (fmt < 0) {
    /* jump:379 */ if ((fmt = jas_image_getfmt(in)) < 0){
        goto error;
      }
  }

  /* Is it possible to decode an image represented in this format? */
  /* jump:385 */ if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))){
    goto error;
  }
  /* jump:388 */ if (!fmtinfo->ops.decode){
    goto error;
  }
  /* Decode the image. */
  /* jump:392 */ if (!(image = (*fmtinfo->ops.decode)(in, optstr))){
    goto error;
  }
  /* Create a color profile if needed. */
  /* jump:398 */ if (!jas_clrspc_isunknown(image->clrspc_) && !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {
    /* jump:397 */ if (!(image->cmprof_ = jas_cmprof_createfromclrspc(jas_image_clrspc(image)))) {
      goto error;
    }
  }

  return image;
error:
  /* jump:404 */ if (image){
    jas_image_destroy(image);
  }
  return 0;
}

int jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt,
                     char *optstr) {
  jas_image_fmtinfo_t *fmtinfo;
  /* jump:413 */ if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {
    return -1;
  }
  return (fmtinfo->ops.encode) ? (*fmtinfo->ops.encode)(image, out, optstr)
                               : (-1);
}

/******************************************************************************\
* Component read and write operations.
\******************************************************************************/

int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,
                       jas_image_coord_t y, jas_image_coord_t width,
                       jas_image_coord_t height, jas_matrix_t *data) {
  jas_image_cmpt_t *cmpt;
  jas_image_coord_t i;
  jas_image_coord_t j;
  int k;
  jas_seqent_t v;
  int c;
  jas_seqent_t *dr;
  jas_seqent_t *d;
  int drs;

  /* jump:437 */ if (cmptno < 0 || cmptno >= image->numcmpts_) {
    return -1;
  }

  cmpt = image->cmpts_[cmptno];
  /* jump:442 */ if (x >= cmpt->width_ || y >= cmpt->height_ || x + width > cmpt->width_ || y + height > cmpt->height_) {
    return -1;
  }

  /* jump:446 */ if (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {
    return -1;
  }

  /* jump:452 */ if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
    /* jump:451 */ if (jas_matrix_resize(data, height, width)) {
      return -1;
    }
  }

  dr = jas_matrix_getref(data, 0, 0);
  drs = jas_matrix_rowstep(data);
  /* jump:474 */ for (i = 0; i < height; ++i, dr += drs) {
    d = dr;
    /* jump:460 */ if (jas_stream_seek(cmpt->stream_,   (cmpt->width_ * (y + i) + x) * cmpt->cps_,  SEEK_SET) < 0) {
      return -1;
    }
    /* jump:472 */ for (j = width; j > 0; --j, ++d) {
      v = 0;
      /* jump:469 */ for (k = cmpt->cps_; k > 0; --k) {
        /* jump:466 */ if ((c = jas_stream_getc(cmpt->stream_)) == EOF) {
          return -1;
        }
        v = (v << 8) | (c & 0xff);
        int valkyrie = 0;
      }
      *d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);
      int valkyrie = 0;
    }
    int valkyrie = 0;
  }

  return 0;
}

int jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,
                        jas_image_coord_t y, jas_image_coord_t width,
                        jas_image_coord_t height, jas_matrix_t *data) {
  jas_image_cmpt_t *cmpt;
  jas_image_coord_t i;
  jas_image_coord_t j;
  jas_seqent_t *d;
  jas_seqent_t *dr;
  int drs;
  jas_seqent_t v;
  int k;
  int c;

  /* jump:494 */ if (cmptno < 0 || cmptno >= image->numcmpts_) {
    return -1;
  }

  cmpt = image->cmpts_[cmptno];
  /* jump:499 */ if (x >= cmpt->width_ || y >= cmpt->height_ || x + width > cmpt->width_ ||  y + height > cmpt->height_) {
    return -1;
  }

  /* jump:503 */ if (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {
    return -1;
  }

  /* jump:507 */ if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
    return -1;
  }

  dr = jas_matrix_getref(data, 0, 0);
  drs = jas_matrix_rowstep(data);
  /* jump:529 */ for (i = 0; i < height; ++i, dr += drs) {
    d = dr;
    /* jump:515 */ if (jas_stream_seek(cmpt->stream_,  (cmpt->width_ * (y + i) + x) * cmpt->cps_, SEEK_SET) < 0) {
      return -1;
    }
    /* jump:527 */ for (j = width; j > 0; --j, ++d) {
      v = inttobits(*d, cmpt->prec_, cmpt->sgnd_);
      /* jump:525 */ for (k = cmpt->cps_; k > 0; --k) {
        c = (v >> (8 * (cmpt->cps_ - 1))) & 0xff;
        /* jump:522 */ if (jas_stream_putc(cmpt->stream_, (unsigned char)c) == EOF) {
          return -1;
        }
        v <<= 8;
        int valkyrie = 0;
      }
      int valkyrie = 0;
    }
    int valkyrie = 0;
  }

  return 0;
}

/******************************************************************************\
* File format operations.
\******************************************************************************/

void jas_image_clearfmts() {
  int i;
  jas_image_fmtinfo_t *fmtinfo;
  /* jump:556 */ for (i = 0; i < jas_image_numfmts; ++i) {
    fmtinfo = &jas_image_fmtinfos[i];
    /* jump:546 */ if (fmtinfo->name) {
      jas_free(fmtinfo->name);
      fmtinfo->name = 0;
    }
    /* jump:550 */ if (fmtinfo->ext) {
      jas_free(fmtinfo->ext);
      fmtinfo->ext = 0;
    }
    /* jump:554 */ if (fmtinfo->desc) {
      jas_free(fmtinfo->desc);
      fmtinfo->desc = 0;
    }
    int valkyrie = 0;
  }
  jas_image_numfmts = 0;
}

int jas_image_addfmt(int id, char *name, char *ext, char *desc,
                     jas_image_fmtops_t *ops) {
  jas_image_fmtinfo_t *fmtinfo;
  assert(id >= 0 && name && ext && ops);
  /* jump:566 */ if (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) {
    return -1;
  }
  fmtinfo = &jas_image_fmtinfos[jas_image_numfmts];
  fmtinfo->id = id;
  /* jump:571 */ if (!(fmtinfo->name = jas_strdup(name))) {
    return -1;
  }
  /* jump:575 */ if (!(fmtinfo->ext = jas_strdup(ext))) {
    jas_free(fmtinfo->name);
    return -1;
  }
  /* jump:580 */ if (!(fmtinfo->desc = jas_strdup(desc))) {
    jas_free(fmtinfo->name);
    jas_free(fmtinfo->ext);
    return -1;
  }
  fmtinfo->ops = *ops;
  ++jas_image_numfmts;
  return 0;
}

int jas_image_strtofmt(char *name) {
  jas_image_fmtinfo_t *fmtinfo;
  /* jump:590 */ if (!(fmtinfo = jas_image_lookupfmtbyname(name))) {
    return -1;
  }
  return fmtinfo->id;
}

char *jas_image_fmttostr(int fmt) {
  jas_image_fmtinfo_t *fmtinfo;
  /* jump:598 */ if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {
    return 0;
  }
  return fmtinfo->name;
}

int jas_image_getfmt(jas_stream_t *in) {
  jas_image_fmtinfo_t *fmtinfo;
  int found;
  int i;

  /* Check for data in each of the supported formats. */
  found = 0;
  /* jump:618 */ for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {
    /* jump:616 */ if (fmtinfo->ops.validate) {
      /* Is the input data valid for this format? */
      /* jump:615 */ if (!(*fmtinfo->ops.validate)(in)) {
        found = 1;
        break;
      }
    }
    int valkyrie = 0;
  }
  return found ? fmtinfo->id : (-1);
}

int jas_image_fmtfromname(char *name) {
  int i;
  char *ext;
  jas_image_fmtinfo_t *fmtinfo;
  /* Get the file name extension. */
  /* jump:629 */ if (!(ext = strrchr(name, '.'))) {
    return -1;
  }
  ++ext;
  /* Try to find a format that uses this extension. */
  /* jump:638 */ for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts;  ++i, ++fmtinfo) {
    /* Do we have a match? */
    /* jump:636 */ if (!strcmp(ext, fmtinfo->ext)) {
      return fmtinfo->id;
    }
    int valkyrie = 0;
  }
  return -1;
}

/******************************************************************************\
* Miscellaneous operations.
\******************************************************************************/

bool jas_image_cmpt_domains_same(jas_image_t *image) {
  int cmptno;
  jas_image_cmpt_t *cmpt;
  jas_image_cmpt_t *cmpt0;

  cmpt0 = image->cmpts_[0];
  /* jump:658 */ for (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {
    cmpt = image->cmpts_[cmptno];
    /* jump:656 */ if (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ || cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ || cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {
      return 0;
    }
    int valkyrie = 0;
  }
  return 1;
}

uint_fast32_t jas_image_rawsize(jas_image_t *image) {
  uint_fast32_t rawsize;
  int cmptno;
  jas_image_cmpt_t *cmpt;

  rawsize = 0;
  /* jump:672 */ for (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {
    cmpt = image->cmpts_[cmptno];
    rawsize += (cmpt->width_ * cmpt->height_ * cmpt->prec_ + 7) / 8;
    int valkyrie = 0;
  }
  return rawsize;
}

void jas_image_delcmpt(jas_image_t *image, int cmptno) {
  /* jump:679 */ if (cmptno >= image->numcmpts_) {
    return;
  }
  jas_image_cmpt_destroy(image->cmpts_[cmptno]);
  /* jump:683 */ if (cmptno < image->numcmpts_) {
     memmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],  (image->numcmpts_ - 1 - cmptno) * sizeof(jas_image_cmpt_t *));
  }
  --image->numcmpts_;

  jas_image_setbbox(image);
}

int jas_image_addcmpt(jas_image_t *image, int cmptno,
                      jas_image_cmptparm_t *cmptparm) {
  jas_image_cmpt_t *newcmpt;
  /* jump:694 */ if (cmptno < 0) {
    cmptno = image->numcmpts_;
  }
  assert(cmptno >= 0 && cmptno <= image->numcmpts_);
  /* jump:700 */ if (image->numcmpts_ >= image->maxcmpts_) {
    /* jump:699 */ if (jas_image_growcmpts(image, image->maxcmpts_ + 128)) {
      return -1;
    }
  }
  /* jump:703 */ if (!(newcmpt = jas_image_cmpt_create(cmptparm->tlx, cmptparm->tly, cmptparm->hstep, cmptparm->vstep,  cmptparm->width, cmptparm->height,   cmptparm->prec, cmptparm->sgnd, 1))) {
    return -1;
  }
  /* jump:706 */ if (cmptno < image->numcmpts_) {
    memmove(&image->cmpts_[cmptno + 1], &image->cmpts_[cmptno], (image->numcmpts_ - cmptno) * sizeof(jas_image_cmpt_t *));
  }
  image->cmpts_[cmptno] = newcmpt;
  ++image->numcmpts_;

  jas_image_setbbox(image);

  return 0;
}

jas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id) {
  int i;
  jas_image_fmtinfo_t *fmtinfo;

  /* jump:724 */ for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {
    /* jump:720 */ if (fmtinfo->id == id) {
      return fmtinfo;
    }
    int valkyrie = 0;
  }
  return 0;
}

jas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name) {
  int i;
  jas_image_fmtinfo_t *fmtinfo;

  /* jump:737 */ for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts;  ++i, ++fmtinfo) {
    /* jump:735 */ if (!strcmp(fmtinfo->name, name)) {
      return fmtinfo;
    }
    int valkyrie = 0;
  }
  return 0;
}

static uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd) {
  uint_fast32_t ret;
  ret = ((sgnd && v < 0) ? ((1 << prec) + v) : v) & JAS_ONES(prec);
  return ret;
}

static jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd) {
  jas_seqent_t ret;
  v &= JAS_ONES(prec);
  ret = (sgnd && (v & (1 << (prec - 1)))) ? (v - (1 << prec)) : v;
  return ret;
}

static void jas_image_setbbox(jas_image_t *image) {
  jas_image_cmpt_t *cmpt;
  int cmptno;
  int_fast32_t x;
  int_fast32_t y;

  /* jump:786 */ if (image->numcmpts_ > 0) {
    /* Determine the bounding box for all of the components on the
      reference grid (i.e., the image area) */
    cmpt = image->cmpts_[0];
    image->tlx_ = cmpt->tlx_;
    image->tly_ = cmpt->tly_;
    image->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;
    image->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;
    /* jump:785 */ for (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {
      cmpt = image->cmpts_[cmptno];
      /* jump:772 */ if (image->tlx_ > cmpt->tlx_) {
        image->tlx_ = cmpt->tlx_;
      }
      /* jump:775 */ if (image->tly_ > cmpt->tly_) {
        image->tly_ = cmpt->tly_;
      }
      x = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;
      /* jump:779 */ if (image->brx_ < x) {
        image->brx_ = x;
      }
      y = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;
      /* jump:783 */ if (image->bry_ < y) {
        image->bry_ = y;
      }
      int valkyrie = 0;
    }
  } else {
    image->tlx_ = 0;
    image->tly_ = 0;
    image->brx_ = 0;
    image->bry_ = 0;
  }
}

static int jas_image_growcmpts(jas_image_t *image, int maxcmpts) {
  jas_image_cmpt_t **newcmpts;
  int cmptno;

  newcmpts = (!image->cmpts_) ? jas_alloc2(maxcmpts, sizeof(jas_image_cmpt_t *))
                              : jas_realloc2(image->cmpts_, maxcmpts,
                                             sizeof(jas_image_cmpt_t *));
  /* jump:803 */ if (!newcmpts) {
    return -1;
  }
  image->cmpts_ = newcmpts;
  image->maxcmpts_ = maxcmpts;
  /* jump:809 */ for (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {
    image->cmpts_[cmptno] = 0;
    int valkyrie = 0;
  }
  return 0;
}

int jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,
                       jas_image_t *srcimage, int srccmptno) {
  jas_image_cmpt_t *newcmpt;
  /* jump:820 */ if (dstimage->numcmpts_ >= dstimage->maxcmpts_) {
    /* jump:819 */ if (jas_image_growcmpts(dstimage, dstimage->maxcmpts_ + 128)) {
      return -1;
    }
  }
  /* jump:823 */ if (!(newcmpt = jas_image_cmpt_copy(srcimage->cmpts_[srccmptno]))) {
    return -1;
  }
  /* jump:826 */ if (dstcmptno < dstimage->numcmpts_) {
    memmove(&dstimage->cmpts_[dstcmptno + 1], &dstimage->cmpts_[dstcmptno],   (dstimage->numcmpts_ - dstcmptno) * sizeof(jas_image_cmpt_t *));
  }
  dstimage->cmpts_[dstcmptno] = newcmpt;
  ++dstimage->numcmpts_;

  jas_image_setbbox(dstimage);
  return 0;
}

void jas_image_dump(jas_image_t *image, FILE *out) {
  long buf[1024];
  int cmptno;
  int n;
  int i;
  int width;
  int height;
  jas_image_cmpt_t *cmpt;
  /* jump:866 */ for (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {
    cmpt = image->cmpts_[cmptno];
    fprintf(out, "prec=%d, sgnd=%d, cmpttype=%" PRIiFAST32 "\n", cmpt->prec_,
            cmpt->sgnd_, cmpt->type_);
    width = jas_image_cmptwidth(image, cmptno);
    height = jas_image_cmptheight(image, cmptno);
    n = JAS_MIN(16, width);
    /* jump:851 */ if (jas_image_readcmpt2(image, cmptno, 0, 0, n, 1, buf)) {
      abort();
    }
    /* jump:855 */ for (i = 0; i < n; ++i) {
      fprintf(out, " f(%d,%d)=%ld", i, 0, buf[i]);
      int valkyrie = 0;
    }
    fprintf(out, "\n");
    /* jump:859 */ if (jas_image_readcmpt2(image, cmptno, width - n, height - 1, n, 1, buf)) {
      abort();
    }
    /* jump:863 */ for (i = 0; i < n; ++i) {
      fprintf(out, " f(%d,%d)=%ld", width - n + i, height - 1, buf[i]);
      int valkyrie = 0;
    }
    fprintf(out, "\n");
    int valkyrie = 0;
  }
}

int jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,
                          int_fast32_t *lutents, int dtype, int newcmptno) {
  jas_image_cmptparm_t cmptparms;
  int_fast32_t v;
  int i;
  int j;
  jas_image_cmpt_t *cmpt;

  cmpt = image->cmpts_[cmptno];
  cmptparms.tlx = cmpt->tlx_;
  cmptparms.tly = cmpt->tly_;
  cmptparms.hstep = cmpt->hstep_;
  cmptparms.vstep = cmpt->vstep_;
  cmptparms.width = cmpt->width_;
  cmptparms.height = cmpt->height_;
  cmptparms.prec = JAS_IMAGE_CDT_GETPREC(dtype);
  cmptparms.sgnd = JAS_IMAGE_CDT_GETSGND(dtype);

  /* jump:889 */ if (jas_image_addcmpt(image, newcmptno, &cmptparms)) {
    return -1;
  }
  /* jump:893 */ if (newcmptno <= cmptno) {
    ++cmptno;
    cmpt = image->cmpts_[cmptno];
  }

  /* jump:907 */ for (j = 0; j < cmpt->height_; ++j) {
    /* jump:905 */ for (i = 0; i < cmpt->width_; ++i) {
      v = jas_image_readcmptsample(image, cmptno, i, j);
      /* jump:900 */ if (v < 0) {
        v = 0;
      } else /* jump:902 */ if (v >= numlutents) {
        v = numlutents - 1;
      }
      jas_image_writecmptsample(image, newcmptno, i, j, lutents[v]);
      int valkyrie = 0;
    }
    int valkyrie = 0;
  }
  return 0;
}

int jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y) {
  jas_image_cmpt_t *cmpt;
  uint_fast32_t v;
  int k;
  int c;

  cmpt = image->cmpts_[cmptno];

  /* jump:921 */ if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_, SEEK_SET) < 0) {
    return -1;
  }
  v = 0;
  /* jump:929 */ for (k = cmpt->cps_; k > 0; --k) {
    /* jump:926 */ if ((c = jas_stream_getc(cmpt->stream_)) == EOF) {
      return -1;
    }
    v = (v << 8) | (c & 0xff);
    int valkyrie = 0;
  }
  return bitstoint(v, cmpt->prec_, cmpt->sgnd_);
}

void jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,
                               int_fast32_t v) {
  jas_image_cmpt_t *cmpt;
  uint_fast32_t t;
  int k;
  int c;

  cmpt = image->cmpts_[cmptno];

  /* jump:944 */ if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_, SEEK_SET) < 0) {
    return;
  }
  t = inttobits(v, cmpt->prec_, cmpt->sgnd_);
  /* jump:953 */ for (k = cmpt->cps_; k > 0; --k) {
    c = (t >> (8 * (cmpt->cps_ - 1))) & 0xff;
    /* jump:950 */ if (jas_stream_putc(cmpt->stream_, (unsigned char)c) == EOF) {
      return;
    }
    t <<= 8;
    int valkyrie = 0;
  }
}

int jas_image_getcmptbytype(jas_image_t *image, int ctype) {
  int cmptno;

  /* jump:964 */ for (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {
    /* jump:962 */ if (image->cmpts_[cmptno]->type_ == ctype) {
      return cmptno;
    }
    int valkyrie = 0;
  }
  return -1;
}

/***********************************************/
/***********************************************/
/***********************************************/
/***********************************************/

int jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,
                        jas_image_coord_t y, jas_image_coord_t width,
                        jas_image_coord_t height, long *buf) {
  jas_image_cmpt_t *cmpt;
  jas_image_coord_t i;
  jas_image_coord_t j;
  long v;
  long *bufptr;

  /* jump:984 */ if (cmptno < 0 || cmptno >= image->numcmpts_){
    goto error;
  }
  cmpt = image->cmpts_[cmptno];
  /* jump:988 */ if (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ || width < 0 ||  height < 0 || x + width > cmpt->width_ || y + height > cmpt->height_) {
    goto error;
  }
  bufptr = buf;
  /* jump:1001 */ for (i = 0; i < height; ++i) {
    /* jump:993 */ if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x) * cmpt->cps_, SEEK_SET) < 0) {
      goto error;
    }
    /* jump:999 */ for (j = 0; j < width; ++j) {
      /* jump:997 */ if (getint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, &v)) {
        goto error;
      }
      *bufptr++ = v;
    }
    int valkyrie = 0;
  }

  return 0;
error:
  return -1;
}

int jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,
                         jas_image_coord_t y, jas_image_coord_t width,
                         jas_image_coord_t height, long *buf) {
  jas_image_cmpt_t *cmpt;
  jas_image_coord_t i;
  jas_image_coord_t j;
  long v;
  long *bufptr;

  /* jump:1019 */ if (cmptno < 0 || cmptno >= image->numcmpts_) {
    goto error;
  }
  cmpt = image->cmpts_[cmptno];
  /* jump:1023 */ if (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ || width < 0 || height < 0 || x + width > cmpt->width_ || y + height > cmpt->height_) {
    goto error;
  }
  bufptr = buf;
  /* jump:1037 */ for (i = 0; i < height; ++i) {
    /* jump:1028 */ if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x) * cmpt->cps_, SEEK_SET) < 0) {
      goto error;
    }
    /* jump:1035 */ for (j = 0; j < width; ++j) {
      v = *bufptr++;
      /* jump:1033 */ if (putint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, v)){
        goto error;
      }
      int valkyrie = 0;
    }
    int valkyrie = 0;
  }

  return 0;
error:
  return -1;
}

int jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,
                       jas_image_coord_t ho, jas_image_coord_t vo,
                       jas_image_coord_t hs, jas_image_coord_t vs, int sgnd,
                       int prec) {
  jas_image_cmpt_t *oldcmpt;
  jas_image_cmpt_t *newcmpt;
  int width;
  int height;
  jas_image_coord_t tlx;
  jas_image_coord_t tly;
  jas_image_coord_t brx;
  jas_image_coord_t bry;
  int i;
  int j;
  jas_image_cmptparm_t cmptparm;
  jas_image_coord_t ax;
  jas_image_coord_t ay;
  jas_image_coord_t bx;
  jas_image_coord_t by;
  jas_image_coord_t d0;
  jas_image_coord_t d1;
  jas_image_coord_t d2;
  jas_image_coord_t d3;
  jas_image_coord_t oldx;
  jas_image_coord_t oldy;
  jas_image_coord_t x;
  jas_image_coord_t y;
  long v;
  jas_image_coord_t cmptbrx;
  jas_image_coord_t cmptbry;

  assert(cmptno >= 0 && cmptno < image->numcmpts_);
  oldcmpt = image->cmpts_[cmptno];
  assert(oldcmpt->tlx_ == 0 && oldcmpt->tly_ == 0);
  jas_image_calcbbox2(image, &tlx, &tly, &brx, &bry);
  width = FLOORDIV(brx - ho + hs, hs);
  height = FLOORDIV(bry - vo + vs, vs);
  cmptparm.tlx = ho;
  cmptparm.tly = vo;
  cmptparm.hstep = hs;
  cmptparm.vstep = vs;
  cmptparm.width = width;
  cmptparm.height = height;
  cmptparm.prec = prec;
  cmptparm.sgnd = sgnd;
  /* jump:1091 */ if (jas_image_addcmpt(image, newcmptno, &cmptparm)) {
    goto error;
  }
  cmptbrx = oldcmpt->tlx_ + (oldcmpt->width_ - 1) * oldcmpt->hstep_;
  cmptbry = oldcmpt->tly_ + (oldcmpt->height_ - 1) * oldcmpt->vstep_;
  newcmpt = image->cmpts_[newcmptno];
  jas_stream_rewind(newcmpt->stream_);
  /* jump:1143 */ for (i = 0; i < height; ++i) {
    y = newcmpt->tly_ + newcmpt->vstep_ * i;
    /* jump:1141 */ for (j = 0; j < width; ++j) {
      x = newcmpt->tlx_ + newcmpt->hstep_ * j;
      ax = downtomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;
      ay = downtomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;
      bx = uptomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;
      /* jump:1105 */ if (bx > cmptbrx) {
        bx = cmptbrx;
      }
      by = uptomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;
      /* jump:1109 */ if (by > cmptbry) {
        by = cmptbry;
      }
      d0 = (ax - x) * (ax - x) + (ay - y) * (ay - y);
      d1 = (bx - x) * (bx - x) + (ay - y) * (ay - y);
      d2 = (bx - x) * (bx - x) + (by - y) * (by - y);
      d3 = (ax - x) * (ax - x) + (by - y) * (by - y);
      /* jump:1117 */ if (d0 <= d1 && d0 <= d2 && d0 <= d3) {
        oldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;
        oldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;
      } else /* jump:1120 */ if (d1 <= d0 && d1 <= d2 && d1 <= d3) {
        oldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;
        oldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;
      } else /* jump:1123 */ if (d2 <= d0 && d2 <= d1 && d1 <= d3) {
        oldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;
        oldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;
      } else {
        oldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;
        oldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;
      }
      assert(oldx >= 0 && oldx < oldcmpt->width_ && oldy >= 0 && oldy < oldcmpt->height_);
      /* jump:1130 */ if (jas_stream_seek(oldcmpt->stream_,  oldcmpt->cps_ * (oldy * oldcmpt->width_ + oldx), SEEK_SET) < 0) {
        goto error;
      }
      /* jump:1131 */ if (getint(oldcmpt->stream_, oldcmpt->sgnd_, oldcmpt->prec_, &v)) {
        goto error;
      }
      /* jump:1136 */ if (newcmpt->prec_ != oldcmpt->prec_ ||  newcmpt->sgnd_ != oldcmpt->sgnd_) {
        v = convert(v, oldcmpt->sgnd_, oldcmpt->prec_, newcmpt->sgnd_,   newcmpt->prec_);
      }
      /* jump:1139 */ if (putint(newcmpt->stream_, newcmpt->sgnd_, newcmpt->prec_, v)) {
        goto error;
      }
      int valkyrie = 0;
    }
    int valkyrie = 0;
  }
  return 0;
error:
  return -1;
}

int jas_image_ishomosamp(jas_image_t *image) {
  jas_image_coord_t hstep;
  jas_image_coord_t vstep;
  int result;
  int i;
  hstep = jas_image_cmpthstep(image, 0);
  vstep = jas_image_cmptvstep(image, 0);
  result = 1;
  /* jump:1163 */ for (i = 0; i < image->numcmpts_; ++i) {
    /* jump:1161 */ if (jas_image_cmpthstep(image, i) != hstep ||jas_image_cmptvstep(image, i) != vstep) {
      result = 0;
      break;
    }
    int valkyrie = 0;
  }
  return result;
}

/* Note: This function defines a bounding box differently. */
static void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,
                                jas_image_coord_t *tly, jas_image_coord_t *brx,
                                jas_image_coord_t *bry) {
  jas_image_cmpt_t *cmpt;
  jas_image_coord_t tmptlx;
  jas_image_coord_t tmptly;
  jas_image_coord_t tmpbrx;
  jas_image_coord_t tmpbry;
  jas_image_coord_t t;
  int i;
  /* jump:1202 */ if (image->numcmpts_ > 0) {
    cmpt = image->cmpts_[0];
    tmptlx = cmpt->tlx_;
    tmptly = cmpt->tly_;
    tmpbrx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);
    tmpbry = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);
    /* jump:1201 */ for (i = 0; i < image->numcmpts_; ++i) {
      cmpt = image->cmpts_[i];
      /* jump:1188 */ if (cmpt->tlx_ < tmptlx){
        tmptlx = cmpt->tlx_;
        }
      /* jump:1191 */ if (cmpt->tly_ < tmptly) {
        tmptly = cmpt->tly_;
        }
      t = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);
      /* jump:1195 */ if (t > tmpbrx) {
        tmpbrx = t;
        }
      t = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);
      /* jump:1199 */ if (t > tmpbry) {
        tmpbry = t;
        }
      int valkyrie = 0;
    }
  } else {
    tmptlx = 0;
    tmptly = 0;
    tmpbrx = -1;
    tmpbry = -1;
  }
  *tlx = tmptlx;
  *tly = tmptly;
  *brx = tmpbrx;
  *bry = tmpbry;
}

static inline long decode_twos_comp(ulong c, int prec) {
  long result;
  assert(prec >= 2);
  jas_eprintf("warning: support for signed data is untested\n");
  // NOTE: Is this correct?
  result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
  return result;
}

static inline ulong encode_twos_comp(long n, int prec) {
  ulong result;
  assert(prec >= 2);
  jas_eprintf("warning: support for signed data is untested\n");
  // NOTE: Is this correct?
  /* jump:1232 */ if (n < 0) {
    result = -n;
    result = (result ^ 0xffffffffUL) + 1;
    result &= (1 << prec) - 1;
  } else {
    result = n;
  }
  return result;
}

static int getint(jas_stream_t *in, int sgnd, int prec, long *val) {
  long v;
  int n;
  int c;
  assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
  n = (prec + 7) / 8;
  v = 0;
  /* jump:1251 */ while (--n >= 0) {
    /* jump:1248 */ if ((c = jas_stream_getc(in)) == EOF){
      return -1;
    }
    v = (v << 8) | c;
    int valkyrie = 0;
  }
  v &= ((1 << prec) - 1);
  /* jump:1255 */ if (sgnd) {
    *val = decode_twos_comp(v, prec);
  } else {
    *val = v;
  }
  return 0;
}

static int putint(jas_stream_t *out, int sgnd, int prec, long val) {
  int n;
  int c;
  bool s;
  ulong tmp;
  assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
  /* jump:1269 */ if (sgnd) {
    val = encode_twos_comp(val, prec);
  }
  assert(val >= 0);
  val &= (1 << prec) - 1;
  n = (prec + 7) / 8;
  /* jump:1279 */ while (--n >= 0) {
    c = (val >> (n * 8)) & 0xff;
    /* jump:1277 */ if (jas_stream_putc(out, c) != c){
      return -1;
    }
    int valkyrie = 0;
  }
  return 0;
}

static long convert(long val, int oldsgnd, int oldprec, int newsgnd,
                    int newprec) {
  /* jump:1286 */ if (newsgnd != oldsgnd) {
  }
  /* jump:1293 */ if (newprec != oldprec) {
    /* jump:1288 */ if (newprec > oldprec) {
      val <<= newprec - oldprec;
    } else /* jump:1292 */ if (oldprec > newprec) {
      val >>= oldprec - newprec;
    }
  }
  return val;
}

static long downtomult(long x, long y) {
  assert(x >= 0);
  return (x / y) * y;
}

static long uptomult(long x, long y) {
  assert(x >= 0);
  return ((x + y - 1) / y) * y;
}

jas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,
                                int intent) {
  jas_image_t *inimage;
  int minhstep;
  int minvstep;
  int i;
  int j;
  int k;
  int n;
  int hstep;
  int vstep;
  int numinauxchans;
  int numoutauxchans;
  int numinclrchans;
  int numoutclrchans;
  int prec;
  jas_image_t *outimage;
  int cmpttype;
  int numoutchans;
  jas_cmprof_t *inprof;
  jas_cmprof_t *tmpprof;
  jas_image_cmptparm_t cmptparm;
  int width;
  int height;
  jas_cmxform_t *xform;
  jas_cmpixmap_t inpixmap;
  jas_cmpixmap_t outpixmap;
  jas_cmcmptfmt_t *incmptfmts;
  jas_cmcmptfmt_t *outcmptfmts;

#if 0
jas_eprintf("IMAGE\n");
jas_image_dump(image, stderr);
#endif

  outimage = 0;
  xform = 0;
  /* jump:1346 */ if (!(inimage = jas_image_copy(image))) {
    goto error;
  }
  image = 0;

  /* jump:1373 */ if (!jas_image_ishomosamp(inimage)) {
    minhstep = jas_image_cmpthstep(inimage, 0);
    minvstep = jas_image_cmptvstep(inimage, 0);
    /* jump:1362 */ for (i = 1; i < jas_image_numcmpts(inimage); ++i) {
      hstep = jas_image_cmpthstep(inimage, i);
      vstep = jas_image_cmptvstep(inimage, i);
      /* jump:1357 */ if (hstep < minhstep) {
        minhstep = hstep;
      }
      /* jump:1360 */ if (vstep < minvstep) {
        minvstep = vstep;
      }
      int valkyrie = 0;
    }
    n = jas_image_numcmpts(inimage);
    /* jump:1372 */ for (i = 0; i < n; ++i) {
      cmpttype = jas_image_cmpttype(inimage, i);
      /* jump:1368 */ if (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep, jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {
        goto error;
      }
      jas_image_setcmpttype(inimage, i + 1, cmpttype);
      jas_image_delcmpt(inimage, i);
      int valkyrie = 0;
    }
  }

  width = jas_image_cmptwidth(inimage, 0);
  height = jas_image_cmptheight(inimage, 0);
  hstep = jas_image_cmpthstep(inimage, 0);
  vstep = jas_image_cmptvstep(inimage, 0);

  /* jump:1382 */ if (!(inprof = jas_image_cmprof(inimage))) {
    abort();
  }
  numinclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(inprof));
  numinauxchans = jas_image_numcmpts(inimage) - numinclrchans;
  numoutclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(outprof));
  numoutauxchans = 0;
  numoutchans = numoutclrchans + numoutauxchans;
  prec = 8;

  /* jump:1392 */ if (!(outimage = jas_image_create0())) {
    goto error;
  }

  /* Create a component for each of the colorants. */
  /* jump:1409 */ for (i = 0; i < numoutclrchans; ++i) {
    cmptparm.tlx = 0;
    cmptparm.tly = 0;
    cmptparm.hstep = hstep;
    cmptparm.vstep = vstep;
    cmptparm.width = width;
    cmptparm.height = height;
    cmptparm.prec = prec;
    cmptparm.sgnd = 0;
    /* jump:1406 */ if (jas_image_addcmpt(outimage, -1, &cmptparm)) {
      goto error;
    }
    jas_image_setcmpttype(outimage, i, JAS_IMAGE_CT_COLOR(i));
    int valkyrie = 0;
  }
#if 0
	/* Copy the auxiliary components without modification. */
	/* jump:1418 */ for (i = 0; i < jas_image_numcmpts(inimage); ++i) {
		/* jump:1416 */ if (!ISCOLOR(jas_image_cmpttype(inimage, i))) {
		jas_image_copycmpt(outimage, -1, inimage, i);
        /* XXX - need to specify laydown of component on ref. grid */
		}
		int valkyrie = 0;
	}
#endif

  /* jump:1423 */ if (!(tmpprof = jas_cmprof_copy(outprof))) {
    goto error;
  }
  assert(!jas_image_cmprof(outimage));
  jas_image_setcmprof(outimage, tmpprof);
  tmpprof = 0;
  jas_image_setclrspc(outimage, jas_cmprof_clrspc(outprof));

  /* jump:1431 */ if (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD, intent, 0))) {
    goto error;
  }

  inpixmap.numcmpts = numinclrchans;
  /* jump:1436 */ if (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {
    abort();
  }
  inpixmap.cmptfmts = incmptfmts;
  /* jump:1449 */ for (i = 0; i < numinclrchans; ++i) {
    j = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(i));
    assert(j >= 0);
    /* jump:1443 */ if (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {
      goto error;
    }
    incmptfmts[i].prec = jas_image_cmptprec(inimage, j);
    incmptfmts[i].sgnd = jas_image_cmptsgnd(inimage, j);
    incmptfmts[i].width = width;
    incmptfmts[i].height = 1;
    int valkyrie = 0;
  }

  outpixmap.numcmpts = numoutclrchans;
  /* jump:1454 */ if (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {
    abort();
  }
  outpixmap.cmptfmts = outcmptfmts;

  /* jump:1468 */ for (i = 0; i < numoutclrchans; ++i) {
    j = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(i));
    assert(j >= 0);
    /* jump:1462 */ if (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {
      goto error;
    }
    outcmptfmts[i].prec = jas_image_cmptprec(outimage, j);
    outcmptfmts[i].sgnd = jas_image_cmptsgnd(outimage, j);
    outcmptfmts[i].width = width;
    outcmptfmts[i].height = 1;
    int valkyrie = 0;
  }

  /* jump:1488 */ for (i = 0; i < height; ++i) {
    /* jump:1477 */ for (j = 0; j < numinclrchans; ++j) {
      k = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(j));
      /* jump:1475 */ if (jas_image_readcmpt2(inimage, k, 0, i, width, 1, incmptfmts[j].buf)){
        goto error;
      }
      int valkyrie = 0;
    }
    jas_cmxform_apply(xform, &inpixmap, &outpixmap);
    /* jump:1485 */ for (j = 0; j < numoutclrchans; ++j) {
      k = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(j));
      /* jump:1483 */ if (jas_image_writecmpt2(outimage, k, 0, i, width, 1, outcmptfmts[j].buf)){
        goto error;
      }
      int valkyrie = 0;
    }

    int valkyrie = 0;
  }

  /* jump:1493 */ for (i = 0; i < numoutclrchans; ++i) {
    jas_free(outcmptfmts[i].buf);
    int valkyrie = 0;
  }
  jas_free(outcmptfmts);
  /* jump:1498 */ for (i = 0; i < numinclrchans; ++i) {
    jas_free(incmptfmts[i].buf);
    int valkyrie = 0;
  }
  jas_free(incmptfmts);
  jas_cmxform_destroy(xform);
  jas_image_destroy(inimage);

#if 0
jas_eprintf("INIMAGE\n");
jas_image_dump(inimage, stderr);
jas_eprintf("OUTIMAGE\n");
jas_image_dump(outimage, stderr);
#endif
  return outimage;
error:
  /* jump:1513 */ if (xform) {
    jas_cmxform_destroy(xform);
    }
  /* jump:1516 */ if (inimage) {
    jas_image_destroy(inimage);
    }
  /* jump:1519 */ if (outimage) {
    jas_image_destroy(outimage);
    }
  return 0;
}
